-- ============================================
-- PHASE 2: DATA CLEANING
-- ============================================

-- STEP 3: Duplicate Management

-- ============================================
-- Objective:
-- Handle duplicates carefully to maintain data integrity and optimize dataset quality:
-- 1. olist_customers: No removal of duplicates since customer_id and customer_unique_id have different purposes.
--    Use customer_unique_id for customer-level analysis.
-- 2. olist_geolocation: Remove redundant rows with identical (lat, lng, zip_code_prefix, city, state) 
--    to reduce redundancy and optimize storage.
-- 3. olist_order_reviews: Manage multiple reviews per order or reviews linked to multiple orders by:
--    - Generating unique review IDs when needed.
--    - Keeping only the earliest review per order when duplicates exist.
-- 4. olist_products & olist_order_items: Verify referential integrity by checking for products not referenced in orders.
--    No deletion is performed since all products are linked, preserving data consistency.
-- ============================================

-- TAB: olist_customers
-- No action needed on this table regarding duplicates.
-- Explanation:
-- customer_id uniquely identifies each order; the same customer may have multiple customer_id values.
-- customer_unique_id identifies a unique customer across all orders.
-- Use customer_unique_id for customer-level analysis to avoid double counting.
-- customer_id is mainly for order-level insights.

-- TAB: olist_geolocation
-- Identify duplicate rows where multiple entries share the same lat, lng, zip_code_prefix, city, and state.
-- Keeping only one entry per zip_code_prefix reduces redundancy and optimizes dataset size.

-- Check for duplicates
SELECT 
    geolocation_lat,
    geolocation_lng,
    geolocation_zip_code_prefix,
    geolocation_city,
    geolocation_state,
    COUNT(*) AS duplicates_row
FROM olist_geolocation
GROUP BY
    geolocation_lat,
    geolocation_lng,
    geolocation_zip_code_prefix,
    geolocation_city,
    geolocation_state
HAVING COUNT(*) > 1
ORDER BY duplicates_row DESC;

-- Count total rows before deleting duplicates
SELECT COUNT(*) AS nbr_total_rows
FROM olist_geolocation;

-- Delete duplicate rows based on all columns that define a location
DELETE FROM olist_geolocation
WHERE (geolocation_lat, geolocation_lng, geolocation_zip_code_prefix, geolocation_city, geolocation_state) IN (
  SELECT geolocation_lat, geolocation_lng, geolocation_zip_code_prefix, geolocation_city, geolocation_state
  FROM olist_geolocation
  GROUP BY geolocation_lat, geolocation_lng, geolocation_zip_code_prefix, geolocation_city, geolocation_state
  HAVING COUNT(*) > 1
);

-- TAB: olist_order_reviews
-- Some orders may have multiple reviews, or identical reviews may exist for different orders.
-- Approach:
-- 1. If a review_id is linked to multiple order_ids, create unique review_ids per order (append suffix).
-- 2. If an order_id has multiple reviews, retain only the earliest review.

-- Create a view to manage review duplicates and generate unique_review_id
CREATE VIEW olist_order_reviews_modified AS
WITH 
  -- Count of distinct orders per review_id
  orders_per_review AS (
    SELECT review_id, COUNT(DISTINCT order_id) AS nb_orders_per_review
    FROM olist_order_reviews
    GROUP BY review_id
  ),
  -- Count of distinct reviews per order_id
  reviews_per_order AS (
    SELECT order_id, COUNT(DISTINCT review_id) AS nb_reviews_per_order
    FROM olist_order_reviews
    GROUP BY order_id
  ),
  -- Add row numbers to manage duplicates
  numbered_reviews AS (
    SELECT
      r.*,
      opr.nb_orders_per_review,
      rpo.nb_reviews_per_order,
      ROW_NUMBER() OVER (PARTITION BY r.review_id ORDER BY r.order_id) AS rn_review_per_review_id,
      ROW_NUMBER() OVER (PARTITION BY r.order_id ORDER BY r.review_creation_date) AS rn_review_per_order
    FROM olist_order_reviews r
    JOIN orders_per_review opr ON r.review_id = opr.review_id
    JOIN reviews_per_order rpo ON r.order_id = rpo.order_id
  )
SELECT
  *,
  CASE
    WHEN nb_orders_per_review = 1 THEN review_id
    ELSE review_id || '-' || rn_review_per_review_id
  END AS unique_review_id
FROM numbered_reviews
WHERE rn_review_per_order = 1  -- Keep only the earliest review per order
ORDER BY order_id, unique_review_id;

-- Select from the modified reviews view
SELECT * FROM olist_order_reviews_modified;

-- TAB: olist_products & olist_order_items
-- Objective: Identify products in olist_products not referenced in any order items.
-- This cleans potential duplicates or unused product records without affecting data integrity.

-- Find products in olist_products not referenced in olist_order_items
SELECT DISTINCT product_id FROM olist_products
EXCEPT
SELECT DISTINCT product_id FROM olist_order_items;

-- Count distinct products in olist_products
SELECT COUNT(DISTINCT product_id) FROM olist_products;

-- Count distinct products in olist_order_items
SELECT COUNT(DISTINCT product_id) FROM olist_order_items;

-- Result:
-- No unreferenced products found; therefore, no deletion performed to maintain referential integrity.
